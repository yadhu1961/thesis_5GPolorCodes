%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction and Motivation} \label{chap:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Era of Computing and Wireless Communication}
Ability to perform computations has evolved tremendously from the day first computer was invented by charles babbage in the 19th century. By the end 19th century another important event occurred, in 1897 an italian inventor and engineer Guglielmo Marconi demonstrated radio's ability to maintain continuous contact with ships in english channel. Major breakthrough happened in the development of computers and wireless systems in 1948, when scientists at the Bell achieved ground breaking results. Claude E.~Shannon published his paper \emph{A mathematical theory of communication} and John Bardeen, Walter Brattain and William Shockley announced the invention of the \emph{transistor effect}. These two landmark events paved way for the widespread adoption of computers and wireless communication systems in numerous applications. Since then telecommunication industry has grown manifold fueled by the advancements in RF and transistor fabrication techniques, miniaturization and Very Large Scale Integration. These technological advances made computing devices smaller, cheaper and more reliable. Recent advances in wireless communication have allowed not only short distance communication such as cellular communication even billions of kilometers distance deep space communication. \newline

Today computing devices and wireless systems have become integral parts of our society. They allow communication between people even from remote areas. Invention of Internet has enabled people to have access to world of information in their fingertips. Till recently, wireless devices were primarily used for information exchange between people. Today wireless applications are entering new avenues such as industrial automation, telemedicine, Autonomous driving. These applications demand ultra-reliability and ultra-low-latency. Latest mobile communication standard 5G took a giant step towards providing service for such mission critical applications. 5G has adopted several techniques to service stringent latency requirements. To name few, different OFDM numerologies, flexible frame structure et cetera. Traditionally to achieve stringent latency requirements wireless communication stacks are implemented in hardware, specifically in FPGAs/ASICs. Hardware implementations make use of implicit hardware-concurrency. However hardware implementations come with inherent non-flexibility, huge cost and high development time. Due to latest technological advancements in general-purpose computing, Modern processors come with a tremendous computation power. It is up to software engineer to efficiently harness this computational power. Modern processors come with special computing units to cater to specific application domains, namely vector processing units for signal processing applications. To achieve stringent latency requirements, it is very important that a software designer makes use of these additional processing elements and available optimization techniques.

%Traditionally FEC chains are developed in hardware i.e FPGA’s or ASIC’s to achieve low latency and high throughput.
%Development in FPGA/hardware requires more time and costly.
%With recent advances in General Purpose Processors it is possible to achieve required latency and throughput with software implementations without custom hardware.
%Software implementations are flexible and easy to maintain compared hardware implementations.
%
%However algorithms need to be adopted/optimized to efficiently implement in software.
%
%Recent advances in the modern processors such as SIMD units can be utilized to achieve low latency and high throughput.

\section{Polar FEC chain development in software}
Commonly high performance signal processing and error correction applications are implemented in hardware either in FPGAs/ASICs. Hardware implementations allow these applications to achieve low latency and high throughput. Algorithms in these applications are developed targeting hardware implementations. These algorithms implemented in software without any reformulation or modification result in poor performance. Therefore algorithms need to be modified and reformulated to achieve expected performance in software. \newline

Optimizations for hardware such as recursive formulation, reducing look up tables (LUTs) and flip flops are not always relevant in software. Let's try to understand conflicts in the optimizations targeted for hardware and software. Most of the encoder/decoder algorithms are formulated in recursive form. In hardware implementations recursive formulations particularly useful since same design can be replicated multiple times without significant design effort also with no performance compromise. However in software implementations recursive implementation incur significant overhead. Mainly due to large of branchings, stack allocation/deallocation and pipeline flushing. Next optimization in hardware targeted implementations is minimizing the required memory and flip-flops. In contrast general purpose computing world can make use of off-the-shelve available cheap memory but software designer should make reduce cache misses, branch miss predictions. In addition, software implementations should also make sure to avoid expensive operations such as multiplications, division and modulus operations. If not, reformulate them by using inexpensive bitwise operators. \newline

It is clear from above discussed details that algorithms directly implemented in software without modification or reformulation result in poor performance. To achieve best performance in software algorithms must be broken down into smaller operations then should be mapped to specific functional units of modern processors. For example, when huge number of floating point/integer operations involved. These computations must be mapped to specialized vector processing units (SIMD) which are specifically designed perform these operations. Mapping to vector processing units allows data parallelism. If algorithm requires lot of memory accesses, software should make use of special cache prefetching units to hide memory access latency. If huge data must be moved copied based on previous decisions, such operations must be mapped to conditional move instructions and so forth.  Figure \ref{fig:operationMapping} gives visual illustration of mapping operations to specialized processing units/instructions.

\begin{figure}[]
	\centering
	\includegraphics[width=1\textwidth]{./figures/operationMapping.pdf}
	\caption{Mapping FEC chain operations to particular functional units}
	\label{fig:operationMapping}
\end{figure}

This thesis work is a step in that direction. It tries to achieve maximum performance out of modern general purpose processors to satisfy stringent latency requirements. Latest 3GPP standard has adopted polar codes for encoding and decoding control channel information \cite{3gpp.38.212}. Downlink control information (DCI) and Uplink control information (UCI) are transmitted using polar codes. In this work, polar encoding and decoding FEC chain is implemented in software. FEC chain algorithms are reformulated/optimized to suit software implementation. FEC chain functionalities are broken down in to primitive operations and are mapped to specific computational units of general purpose processor. Implementation uses off-the-shelf available AMD EPYC general purpose processor\cite{amdEpyc}. It comes with state-of-the art instruction extensions. These advanced instructions allow mapping different operations in FEC chain implementation to specialized processing units to maximize performance.

Software implementation in this work makes extensive use of vector processing units, cache prefetching, branch prediction and compiler optimizations to achieve low latency. After the implementation each component of FEC chain performance of naive and optimized implementations are presented. At the end of encoding and decoding FEC chain chapters, latency whole FEC chain  is presented. Comparison between functional and optimized implementation is given to understand the importance of software optimizations. In decoding FEC chain chapter performance of implemented decoder is compared with state of the art software decoder implementation \cite{lowLatencySWPolarDec}.

\section*{Organization of the Thesis}
Having described the overall problem and relevant motivation, in Chapter 2 the necessary background to develop polar FEC chain is provided. Including required mathematical understanding of polar codes and fundamentals of modern computer architecture. In Chapter 3, details of the polar encoding FEC chain are presented. Each of components are analyzed for latency contribution. Both algorithmic and software optimizations are employed. At end latency of naive and optimized implementations are compared. In Chapter 4, details of polar decoding FEC chain are presented. Operation of different components in the FEC chain are given in detail. Each operation is optimized by mapping them efficiently specific instructions/processing units. Decoder algorithm optimizations are presented and compared with state of the art software decoder implementations. Finally at end of Chapter 3, latency of the optimized decoding FEC chain is compared with the naive implementation.