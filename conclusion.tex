\chapter{Conclusion and Outlook} \label{chap:conclusion}
The objective of this work is to study the feasibility of developing polar FEC chain of 5G in software on general-purpose-processor while satisfying stringent latency requirements. In other words, all the components of encoder and decoder FEC chain are developed on general purpose AMD EPYC processor. The software satisfies latency constraint of less than 50$\mu$s. In the first part of the thesis, we provide necessary background about polar encoding/decoding and computer architecture. In the second part, we develop encoding and decoding FEC chains and optimize them to satisfy the necessary latency constraints. \newline

To begin with, we provided necessary mathematical background about polar code construction, polar encoding, and decoding. Including different polar decoding algorithms. To understand FEC chain development in software it is necessary to know the basics of modern computer architecture. Computer architecture section talks about pipelining, cache memory and vector processing units in modern general purpose processors. \newline

In the next chapter, we talk about the details of polar encoding FEC chain. In this chapter, we analyze the different components of the FEC chain to identify latency contributors. Each of these latency contributors is further studied to reformulate the algorithm to avoid costly operations. Algorithms are reformulated to fit into specialized functional units of modern processors such as vector processing units. Vector processing units allow data parallelism in addition to supporting very fast mathematical computations. The encoding,  major latency contributors were polar code construction, CRC calculation, encoding, and rate matching. A wide range of optimization techniques is employed to reduce the latency both algorithmic and platform specific. Namely, reducing algorithm complexity, using lookup tables, compiler hints for better instruction scheduling, vector processing instructions for data parallelism and avoiding superfluous copy operations et cetera. Optimizations reduced the worst-case latency of the encoding FEC chain from $451 \mu$s to $40\mu$s which is more than 10x reduction in latency. \newline

For the decoding FEC chain again same steps as encoding chain are followed to identify the latency contributors. Major contributors in decoding FEC chain were channel deinterleaver, subblock deinterlever, polar decoder, parity bit extractor, and CRC calculation. Decoding FEC chain extensively uses SIMD, bit count, cache prefetching instructions to reduce latency. Subblock deinterleaving operation is divided into three primitive small operations which are implemented efficiently with $\mathtt{permute}$ and $\mathtt{blend}$ vector instructions. The polar decoder is optimized by implementing XOR, CN, VN, bit combination and frozen pattern identification operations using vector processing instructions. Parity bit extractor optimized by avoiding expensive remove and erase operations instead uses modified algorithm marking indexes and dynamically calculating hamming weights of generator matrix rows. Finally, for CRC calculation an algorithm based on lookup table is developed based on \cite{Sarwate:1988:CCR:63030.63037} which processes block of data bits to calculate CRC. These optimizations significantly reduced the latency of decoding FEC chain from $391 \mu$s to $40\mu$s almost a 10x reduction in latency. \newline

As an outlook, for the above stated decoding FEC chain, decoder is developed with \emph{fast-SSC} algorithm. This algorithm has much lower error correction performance than similar block-length LDPC and Turbo counterparts. As part of this work, \emph{CRC-Aided Successive Cancellation List} (\emph{CA-SCL})\cite{SCL} decoding algorithm is also implemented, however, it is not optimized for software. \emph{CA-SCL} ideally suits very low SNR scenarios such as mmWave communication. It has approximately $1.5dB$ gain over \emph{fast-SSC} algorithm for $N=2048$ and list size $L = 8$. Ideal continuation of this work would be to extend the decoding chain by incorporating \emph{CA-SCL} algorithm to the FEC chain. It would be interesting to see the latency values of this algorithm, which has expensive \emph{sort} and \emph{copying} operations.